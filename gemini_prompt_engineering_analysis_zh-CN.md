# Gemini Core 提示工程 (Prompt Engineering) 分析

本文档详细分析了 `gemini/core` 代码库中提示工程的实现方式。其核心思想是为AI代理提供一个极其详尽、结构化且能感知上下文的“行为手册”，而不仅仅是简单的指令。

### 1. 核心系统提示 (`getCoreSystemPrompt`)

这是提示工程的核心，位于 `packages/core/src/core/prompts.ts` 文件中。它不像常规提示那样只有一两句话，而是一份详尽的文档，包含了以下关键技术：

*   **精细的角色扮演**：提示开篇就为AI代理设定了明确的角色：“一个专注于软件工程任务的交互式CLI代理”。这有助于模型生成更专业、更符合场景的回答。
*   **结构化的行为准则**：提示被分成了“核心指令”、“主要工作流”、“操作指南”和“安全规则”等部分，严格规定了代理在修改代码、使用工具、与用户交互时的行为准则。
*   **预设工作流 (SOP)**：为“软件工程任务”和“创建新应用”等复杂场景预设了标准作业流程（SOP）。例如，在修改代码前，代理被要求必须先使用工具搜索和阅读相关文件来理解上下文，然后制定计划，最后才动手实现。
*   **少量示例 (Few-shot Examples)**：提示中包含了大量的 `<example>` 对话示例，向模型直观地展示了在不同情境下（如执行命令、重构代码、回答问题）应该如何与用户交互、如何使用工具。这是最有效的提示工程技术之一。
*   **动态与情境感知**：最精妙的一点是，这个系统提示是“活”的。它会根据当前环境动态调整内容：
    *   **Git感知**：如果检测到当前项目是一个Git仓库，提示中会自动加入关于如何使用`git`命令（如`git status`, `git diff`）和如何撰写规范的Commit Message的详细指南。
    *   **沙箱感知**：如果检测到代理在沙箱中运行，提示会补充关于沙箱环境限制的说明。
    *   **工具名注入**：提示中引用的工具名称（如`${ReadFileTool.Name}`）是动态从代码中注入的，保证了提示与实现的一致性。

### 2. 对话历史压缩提示 (`getCompressionPrompt`)

为了解决长对话中上下文丢失的问题，`gemini/core` 设计了一个专门的“压缩提示”。当对话历史变得过长时，它会调用一个模型，并使用这个高度结构化的提示，将历史记录压缩成一个XML格式的`<state_snapshot>`（状态快照）。这个快照包含了“总体目标”、“关键知识”、“文件系统状态”和“当前计划”等字段，确保了关键记忆的无损保留，这是一种非常高级的长期记忆管理策略。

### 3. 可扩展的提示注册表 (`prompt-registry.ts`)

`gemini/core` 还设计了一个 `PromptRegistry`（提示注册表）。它允许通过模型中心协议（MCP）连接的外部工具或服务动态地注册自己的提示。这意味着整个提示系统是可扩展的，第三方开发者可以为代理“注入”新的能力和知识，而无需修改核心代码。

### 总结

`gemini/core` 的提示工程是一个复杂而强大的系统。它通过**超详细的系统提示**为代理设定了“性格”和“行为准则”，通过**少量示例**教会代理“如何互动”，通过**动态注入**让代理能够“感知环境”，并通过**结构化的压缩提示**赋予代理“长期记忆”。这是一个非常值得学习和借鉴的专业级提示工程实现。
