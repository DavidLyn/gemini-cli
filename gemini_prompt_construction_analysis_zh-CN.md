# Gemini Core 提示词构造深度分析

本文档深入剖析 `gemini/core` 在不同工作场景下，是如何动态地、分层地构造发送给大语言模型（LLM）的提示词（Prompt）。这个过程远比直接发送用户输入要复杂，是其强大能力的核心。

### 核心构造流程

所有提示词的构造都遵循一个基本模式：**基础模板 + 动态上下文 + 对话历史 + 用户指令**。

---

### 场景一：基础聊天对话

这是最简单但也是最基础的场景，例如用户输入“你好”或“解释一下什么是递归”。

1.  **注入“灵魂” - 系统提示 (System Prompt)**：
    *   调用 `getCoreSystemPrompt()` 函数，加载一个非常庞大和详尽的“系统提示”。
    *   这个提示为AI代理设定了核心角色（软件工程专家）、行为准则（如模仿项目风格、严谨验证）、工作流程和安全规则。这是每次对话的基石，决定了代理的“性格”和能力边界。

2.  **感知“环境” - 上下文注入**：
    *   在对话开始时，程序会自动检测当前的工作环境（操作系统、当前路径、是否在Git仓库内等），并将这些信息作为初始对话注入历史，让代理从一开始就对它所处的环境有基本认知。

3.  **加载“记忆” - 对话历史 (Chat History)**：
    *   获取到目前为止的完整对话历史记录。

4.  **明确“指令” - 用户输入 (User Input)**：
    *   将用户当前的输入作为最后一条 `user` 角色的消息添加进去。

最终发送给大模型的是一个结构化的内容数组，格式为：`[系统提示, 环境信息, ..., 对话历史, 用户当前输入]`。

---

### 场景二：需要使用工具的复杂任务

当用户的指令需要调用工具时（例如“列出当前目录的文件”），这个过程会变为一个巧妙的“两步走”策略：

1.  **第一步：决策使用哪个工具**
    *   **构造带有“工具库”的提示**：除了基础对话的所有内容，程序还会将所有已注册工具的详细“功能声明”（Function Declaration，包括工具名、功能描述、参数列表和类型）一并发送给大模型。
    *   **模型的“工具调用”决策**：大模型在理解了用户的意图和它所拥有的“工具库”后，会判断出需要使用哪个工具以及如何传递参数。它的回复不是一段文字，而是一个结构化的 `functionCall` 对象，例如：`{ "name": "list_directory", "arguments": { "path": "/path/to/project" } }`。

2.  **第二步：理解工具结果并回复**
    *   **执行工具并构造“结果”提示**：`gemini/core` 在收到 `functionCall` 后，会在本地执行对应的工具代码，并获取输出结果（例如，文件列表）。然后，它会构造一个新的提示，将这个工具的输出结果包装成一个 `functionResponse` 对象，添加到对话历史中。
    *   **模型的最终回复**：大模型在收到了包含工具执行结果的新提示后，会“理解”这个结果，并生成一段通顺的、人类可读的自然语言回复给用户。

这个“思考 -> 调用工具 -> 理解结果 -> 回复”的流程，是代理能够完成复杂任务的核心。

---

### 场景三：超长对话中的历史压缩

为防止在长对话中丢失上下文，`gemini/core` 设计了精巧的“记忆压缩”机制：

1.  **触发压缩**：`GeminiClient` 会监控对话历史的token数量，一旦超过阈值便启动压缩流程。
2.  **构造“压缩专用”提示**：程序会使用一个完全不同的、为压缩任务专门设计的系统提示 (`getCompressionPrompt`)。这个提示会命令模型扮演一个“状态管理员”，将整个对话历史提炼成一个高度结构化的XML格式的 `<state_snapshot>`（状态快照）。
3.  **重建“记忆”**：模型返回这个XML快照后，`gemini/core` 会用这个简短但信息密集的快照来替换掉原来冗长的对话历史，从而大大缩减了token占用。新的对话历史就像是：“这是我们之前的对话快照...”，然后在此基础上继续新的对话。

---

### 场景四：与IDE集成，感知代码上下文

当在VS Code等IDE环境中使用时，提示构造会增加一个关键步骤，让代理仿佛拥有“眼睛”：

1.  **注入IDE上下文**：在发送用户指令前，`GeminiClient` 会通过 `ide-client` 获取用户编辑器当前的状态，包括**当前打开了哪些文件、光标在哪一行、选中了哪些代码**等。
2.  **增量或全量更新**：为了效率，它会智能地判断是发送全部状态，还是只发送自上一轮对话以来的“变化量”（例如，用户切换了文件或移动了光标）。
3.  **构造为JSON注入提示**：这些IDE状态信息会被格式化成一个JSON对象，并作为一条 `user` 消息（例如“这是用户当前的编辑器上下文：...`json...`”）插入到用户的实际问题之前。

这使得代理能够“看到”用户正在操作的界面，从而给出更精准的、与代码紧密相关的辅助。

### 总结

`gemini/core` 的提示词构造是一个动态、分层、且高度自动化的系统。它通过组合静态的“行为手册”、动态的“环境与工具信息”、以及实时的“IDE状态”，为大模型在各种场景下执行任务提供了最丰富、最有效的上下文，这正是其强大能力的核心所在。
