# “场景一：基础聊天对话”提示词构造四步骤详解

本文档详细拆解在“基础聊天对话”这个最核心的场景中，`gemini/core` 是如何一步步构造出最终发送给大模型的提示词的。每一步都注入了关键信息，共同构成了一个高质量的提示。

### 第一步：注入“灵魂” - 系统提示 (System Prompt)

*   **详细解释：** 这一步是所有提示的根基。程序会调用 `getCoreSystemPrompt()` 函数，这个函数返回的不是一两句简单的指令，而是一份极其详尽、长达数百行的“行为手册”。
*   **内容构成：**
    *   **核心指令 (Core Mandates):** 规定了编码时的铁律，如“严格遵守项目现有规范”、“模仿现有代码风格”等。
    *   **主要工作流 (Primary Workflows):** 为软件开发和创建新应用等复杂任务，定义了标准的、分步骤的操作流程（SOP），例如“理解 -> 计划 -> 实施 -> 验证”。
    *   **操作指南 (Operational Guidelines):** 定义了交互语气（简洁、直接）、工具使用规范（必须用绝对路径）和安全准则。
    *   **少量示例 (Few-shot Examples):** 包含了大量 `<example>` 对话范例，直观地向模型展示了在不同情境下应该如何回应和行动。
*   **动态特性：** 这份“手册”是活的。它会通过代码检测当前环境，如果项目在 Git 仓库中，就会自动加入关于如何使用 `git` 的详细指南；如果程序在沙箱中运行，就会补充沙箱限制的说明。
*   **总结：** 这一步为模型注入了一个专业的“软件工程师”人格，并设定了其行为框架和能力边界。

### 第二步：感知“环境” - 上下文注入 (Environment Context)

*   **详细解释：** 在对话刚开始时，为了让模型了解它“身在何处”，程序会通过 `getEnvironmentContext` 和 `getDirectoryContextString` 等函数收集当前工作环境的关键信息。
*   **收集内容：**
    *   **操作系统信息：** 例如 `Linux`, `macOS`, `Windows`。
    *   **Shell类型：** 当前使用的命令行Shell，如 `bash`, `zsh`。
    *   **当前工作目录：** 项目的绝对路径。
    *   **目录结构概览：** 可能会包含当前目录下文件和文件夹的一个高级视图。
*   **注入方式：** 这些环境信息被打包成一个 `user` 角色的消息，作为整个对话历史的“开场白”。例如，历史记录的第一条可能是 `role: 'user', parts: [{ text: 'OS: macOS\nCWD: /home/user/project\n...' }]`。
*   **总结：** 这一步让模型对它所操作的环境有了“全局视野”，避免了它在完全无知的情况下进行工作。

### 第三步：加载“记忆” - 对话历史 (Chat History)

*   **详细解释：** 这一步看似简单，就是把之前的对话放进来，但 `GeminiChat` 类在背后做了精细的管理。
*   **角色完整性：** 它会确保历史记录严格遵守 `user` 和 `model` 交替出现的格式，这是许多大模型API的强制要求。
*   **历史“净化” (Curation):** `GeminiChat` 包含一个 `extractCuratedHistory` 的逻辑。如果模型之前的回复因为安全策略等原因生成了无效或空的内容，这个逻辑会将其从发送给模型的历史中剔除，保证了对话的“干净”和连贯性。
*   **总结：** 这一步不仅是简单的信息堆叠，更是一个维护对话质量和格式正确的管理过程，保证了上下文的有效传递。

### 第四步：明确“指令” - 用户当前输入 (User Input)

*   **详细解释：** 这是构造提示的最后一步，也是最直接的一步。
*   **封装为标准格式：** 当用户输入指令后（例如“帮我读一下 a.txt 文件”），程序会调用 `createUserContent` 之类的函数，将这段文本封装成一个标准化的 `Content` 对象。这个对象的格式为 `{ role: 'user', parts: [{ text: '帮我读一下 a.txt 文件' }] }`。
*   **追加到末尾：** 这个代表用户最新指令的对象，会被追加到包含了系统提示、环境上下文和历史记录的数组的末尾。
*   **总结：** 这一步将用户的即时需求清晰地、结构化地呈现给模型，作为模型需要立即响应和处理的核心任务。

**最终形态：**
经过这四步，最终发送给大模型的是一个精心构造、信息密度极高的 `Content` 对象数组。它既有宏观的“我是谁，我该怎么做”（系统提示），又有中观的“我在哪里”（环境上下文）和“我们聊了什么”（对话历史），最后还有微观的“现在要做什么”（用户输入）。这种分层、多维度的信息构造，是 `gemini/core` 能够准确、高效完成复杂任务的关键所在。
